-- Create notifications table
create table if not exists public.notifications (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  title text not null,
  message text not null,
  type text not null,
  is_read boolean default false,
  data jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS
alter table public.notifications enable row level security;

-- Policies
create policy "Users can view their own notifications"
  on public.notifications for select
  using ( auth.uid() = user_id );

create policy "Users can update their own notifications"
  on public.notifications for update
  using ( auth.uid() = user_id );

-- IMPORTANT: Allow anyone (server side logic often runs as the user) or specifically admin to insert
-- Since your app inserts notifications from the client side during checkout (user triggers it) or admin (admin triggers it for another user)
-- We need a policy that allows insertion.

-- Policy for Users to insert notifications (e.g. for themselves or system triggers if running as client)
-- WARNING: In a strict prod env, you'd likely do this via Database Triggers or Edge Functions to verify integrity.
-- For this MVP, we allow authenticated users to insert.
create policy "Authenticated users can insert notifications"
  on public.notifications for insert
  with check ( auth.role() = 'authenticated' );

-- If you are an Admin updating someone else's order, you need to be able to insert a row where user_id != auth.uid()
-- The above policy allows authenticated users to insert *any* row. 
-- If you want to be stricter:
-- create policy "Admins can insert notifications for anyone" ... but checking "is_admin" claim is complex in basic RLS without a profiles table lookup.

-- Policy for reading:
-- If you are using the Service Role key in backend, RLS is bypassed. 
-- If you are using Client Key in Flutter:
-- Admins need to be able to insert for others. The 'insert' policy above allows it.
